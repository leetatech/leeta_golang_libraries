<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# filter

```go
import "github.com/leetatech/leeta_golang_libraries/query/filter"
```

## Index

- [Variables](<#variables>)
- [func AggregateMetricNames\(\) \[\]string](<#AggregateMetricNames>)
- [func CompareOperatorNames\(\) \[\]string](<#CompareOperatorNames>)
- [func ControlTypeNames\(\) \[\]string](<#ControlTypeNames>)
- [func LogicOperatorNames\(\) \[\]string](<#LogicOperatorNames>)
- [type AggregateMetric](<#AggregateMetric>)
  - [func ParseAggregateMetric\(name string\) \(AggregateMetric, error\)](<#ParseAggregateMetric>)
  - [func \(x AggregateMetric\) IsValid\(\) bool](<#AggregateMetric.IsValid>)
  - [func \(x AggregateMetric\) MarshalText\(\) \(\[\]byte, error\)](<#AggregateMetric.MarshalText>)
  - [func \(x \*AggregateMetric\) Scan\(value interface\{\}\) \(err error\)](<#AggregateMetric.Scan>)
  - [func \(x AggregateMetric\) String\(\) string](<#AggregateMetric.String>)
  - [func \(x \*AggregateMetric\) UnmarshalText\(text \[\]byte\) error](<#AggregateMetric.UnmarshalText>)
  - [func \(x AggregateMetric\) Value\(\) \(driver.Value, error\)](<#AggregateMetric.Value>)
- [type CompareOperator](<#CompareOperator>)
  - [func ParseCompareOperator\(name string\) \(CompareOperator, error\)](<#ParseCompareOperator>)
  - [func \(x CompareOperator\) IsValid\(\) bool](<#CompareOperator.IsValid>)
  - [func \(x CompareOperator\) MarshalText\(\) \(\[\]byte, error\)](<#CompareOperator.MarshalText>)
  - [func \(x \*CompareOperator\) Scan\(value interface\{\}\) \(err error\)](<#CompareOperator.Scan>)
  - [func \(x CompareOperator\) String\(\) string](<#CompareOperator.String>)
  - [func \(x \*CompareOperator\) UnmarshalText\(text \[\]byte\) error](<#CompareOperator.UnmarshalText>)
  - [func \(x CompareOperator\) Value\(\) \(driver.Value, error\)](<#CompareOperator.Value>)
- [type ControlType](<#ControlType>)
  - [func ParseControlType\(name string\) \(ControlType, error\)](<#ParseControlType>)
  - [func \(x ControlType\) IsValid\(\) bool](<#ControlType.IsValid>)
  - [func \(x ControlType\) MarshalText\(\) \(\[\]byte, error\)](<#ControlType.MarshalText>)
  - [func \(x \*ControlType\) Scan\(value interface\{\}\) \(err error\)](<#ControlType.Scan>)
  - [func \(x ControlType\) String\(\) string](<#ControlType.String>)
  - [func \(x \*ControlType\) UnmarshalText\(text \[\]byte\) error](<#ControlType.UnmarshalText>)
  - [func \(x ControlType\) Value\(\) \(driver.Value, error\)](<#ControlType.Value>)
- [type LogicOperator](<#LogicOperator>)
  - [func ParseLogicOperator\(name string\) \(LogicOperator, error\)](<#ParseLogicOperator>)
  - [func \(x LogicOperator\) IsValid\(\) bool](<#LogicOperator.IsValid>)
  - [func \(x LogicOperator\) MarshalText\(\) \(\[\]byte, error\)](<#LogicOperator.MarshalText>)
  - [func \(x \*LogicOperator\) Scan\(value interface\{\}\) \(err error\)](<#LogicOperator.Scan>)
  - [func \(x LogicOperator\) String\(\) string](<#LogicOperator.String>)
  - [func \(x \*LogicOperator\) UnmarshalText\(text \[\]byte\) error](<#LogicOperator.UnmarshalText>)
  - [func \(x LogicOperator\) Value\(\) \(driver.Value, error\)](<#LogicOperator.Value>)
- [type ReadableValue](<#ReadableValue>)
- [type Request](<#Request>)
- [type RequestField](<#RequestField>)
- [type RequestOption](<#RequestOption>)
- [type RequestOptionType](<#RequestOptionType>)


## Variables

<a name="ErrInvalidAggregateMetric"></a>

```go
var ErrInvalidAggregateMetric = fmt.Errorf("not a valid AggregateMetric, try [%s]", strings.Join(_AggregateMetricNames, ", "))
```

<a name="ErrInvalidCompareOperator"></a>

```go
var ErrInvalidCompareOperator = fmt.Errorf("not a valid CompareOperator, try [%s]", strings.Join(_CompareOperatorNames, ", "))
```

<a name="ErrInvalidControlType"></a>

```go
var ErrInvalidControlType = fmt.Errorf("not a valid ControlType, try [%s]", strings.Join(_ControlTypeNames, ", "))
```

<a name="ErrInvalidLogicOperator"></a>

```go
var ErrInvalidLogicOperator = fmt.Errorf("not a valid LogicOperator, try [%s]", strings.Join(_LogicOperatorNames, ", "))
```

<a name="AggregateMetricNames"></a>
## func AggregateMetricNames

```go
func AggregateMetricNames() []string
```

AggregateMetricNames returns a list of possible string values of AggregateMetric.

<a name="CompareOperatorNames"></a>
## func CompareOperatorNames

```go
func CompareOperatorNames() []string
```

CompareOperatorNames returns a list of possible string values of CompareOperator.

<a name="ControlTypeNames"></a>
## func ControlTypeNames

```go
func ControlTypeNames() []string
```

ControlTypeNames returns a list of possible string values of ControlType.

<a name="LogicOperatorNames"></a>
## func LogicOperatorNames

```go
func LogicOperatorNames() []string
```

LogicOperatorNames returns a list of possible string values of LogicOperator.

<a name="AggregateMetric"></a>
## type AggregateMetric

AggregateMetric ENUM\(

```
sum
min
max
avg

valueCount
```

\)

```go
type AggregateMetric string
```

<a name="AggregateMetricSum"></a>

```go
const (
    // AggregateMetricSum is a AggregateMetric of type sum.
    AggregateMetricSum AggregateMetric = "sum"
    // AggregateMetricMin is a AggregateMetric of type min.
    AggregateMetricMin AggregateMetric = "min"
    // AggregateMetricMax is a AggregateMetric of type max.
    AggregateMetricMax AggregateMetric = "max"
    // AggregateMetricAvg is a AggregateMetric of type avg.
    AggregateMetricAvg AggregateMetric = "avg"
    // AggregateMetricValueCount is a AggregateMetric of type valueCount.
    AggregateMetricValueCount AggregateMetric = "valueCount"
)
```

<a name="ParseAggregateMetric"></a>
### func ParseAggregateMetric

```go
func ParseAggregateMetric(name string) (AggregateMetric, error)
```

ParseAggregateMetric attempts to convert a string to a AggregateMetric.

<a name="AggregateMetric.IsValid"></a>
### func \(AggregateMetric\) IsValid

```go
func (x AggregateMetric) IsValid() bool
```

IsValid provides a quick way to determine if the typed value is part of the allowed enumerated values

<a name="AggregateMetric.MarshalText"></a>
### func \(AggregateMetric\) MarshalText

```go
func (x AggregateMetric) MarshalText() ([]byte, error)
```

MarshalText implements the text marshaller method.

<a name="AggregateMetric.Scan"></a>
### func \(\*AggregateMetric\) Scan

```go
func (x *AggregateMetric) Scan(value interface{}) (err error)
```

Scan implements the Scanner interface.

<a name="AggregateMetric.String"></a>
### func \(AggregateMetric\) String

```go
func (x AggregateMetric) String() string
```

String implements the Stringer interface.

<a name="AggregateMetric.UnmarshalText"></a>
### func \(\*AggregateMetric\) UnmarshalText

```go
func (x *AggregateMetric) UnmarshalText(text []byte) error
```

UnmarshalText implements the text unmarshaller method.

<a name="AggregateMetric.Value"></a>
### func \(AggregateMetric\) Value

```go
func (x AggregateMetric) Value() (driver.Value, error)
```

Value implements the driver Valuer interface.

<a name="CompareOperator"></a>
## type CompareOperator

CompareOperator ENUM\(

```
beginsWith
			doesNotBeginWith
			contains
			doesNotContain

			textContains

			isNumberEqualTo
			isEqualTo
			isIpEqualTo
			isStringEqualTo
			isStringCaseInsensitiveEqualTo

			isNotEqualTo
			isNumberNotEqualTo
			isIpNotEqualTo
			isStringNotEqualTo

			isGreaterThan
			isGreaterThanOrEqualTo
			isLessThan
			isLessThanOrEqualTo
			beforeDate
			afterDate

			exists

			isEqualToRating
            isNotEqualToRating
		    isGreaterThanRating
	        isLessThanRating
			isGreaterThanOrEqualToRating
	        isLessThanOrEqualToRating

			betweenDates
```

\)

```go
type CompareOperator string
```

<a name="CompareOperatorBeginsWith"></a>

```go
const (
    // CompareOperatorBeginsWith is a CompareOperator of type beginsWith.
    CompareOperatorBeginsWith CompareOperator = "beginsWith"
    // CompareOperatorDoesNotBeginWith is a CompareOperator of type doesNotBeginWith.
    CompareOperatorDoesNotBeginWith CompareOperator = "doesNotBeginWith"
    // CompareOperatorContains is a CompareOperator of type contains.
    CompareOperatorContains CompareOperator = "contains"
    // CompareOperatorDoesNotContain is a CompareOperator of type doesNotContain.
    CompareOperatorDoesNotContain CompareOperator = "doesNotContain"
    // CompareOperatorTextContains is a CompareOperator of type textContains.
    CompareOperatorTextContains CompareOperator = "textContains"
    // CompareOperatorIsNumberEqualTo is a CompareOperator of type isNumberEqualTo.
    CompareOperatorIsNumberEqualTo CompareOperator = "isNumberEqualTo"
    // CompareOperatorIsEqualTo is a CompareOperator of type isEqualTo.
    CompareOperatorIsEqualTo CompareOperator = "isEqualTo"
    // CompareOperatorIsIpEqualTo is a CompareOperator of type isIpEqualTo.
    CompareOperatorIsIpEqualTo CompareOperator = "isIpEqualTo"
    // CompareOperatorIsStringEqualTo is a CompareOperator of type isStringEqualTo.
    CompareOperatorIsStringEqualTo CompareOperator = "isStringEqualTo"
    // CompareOperatorIsStringCaseInsensitiveEqualTo is a CompareOperator of type isStringCaseInsensitiveEqualTo.
    CompareOperatorIsStringCaseInsensitiveEqualTo CompareOperator = "isStringCaseInsensitiveEqualTo"
    // CompareOperatorIsNotEqualTo is a CompareOperator of type isNotEqualTo.
    CompareOperatorIsNotEqualTo CompareOperator = "isNotEqualTo"
    // CompareOperatorIsNumberNotEqualTo is a CompareOperator of type isNumberNotEqualTo.
    CompareOperatorIsNumberNotEqualTo CompareOperator = "isNumberNotEqualTo"
    // CompareOperatorIsIpNotEqualTo is a CompareOperator of type isIpNotEqualTo.
    CompareOperatorIsIpNotEqualTo CompareOperator = "isIpNotEqualTo"
    // CompareOperatorIsStringNotEqualTo is a CompareOperator of type isStringNotEqualTo.
    CompareOperatorIsStringNotEqualTo CompareOperator = "isStringNotEqualTo"
    // CompareOperatorIsGreaterThan is a CompareOperator of type isGreaterThan.
    CompareOperatorIsGreaterThan CompareOperator = "isGreaterThan"
    // CompareOperatorIsGreaterThanOrEqualTo is a CompareOperator of type isGreaterThanOrEqualTo.
    CompareOperatorIsGreaterThanOrEqualTo CompareOperator = "isGreaterThanOrEqualTo"
    // CompareOperatorIsLessThan is a CompareOperator of type isLessThan.
    CompareOperatorIsLessThan CompareOperator = "isLessThan"
    // CompareOperatorIsLessThanOrEqualTo is a CompareOperator of type isLessThanOrEqualTo.
    CompareOperatorIsLessThanOrEqualTo CompareOperator = "isLessThanOrEqualTo"
    // CompareOperatorBeforeDate is a CompareOperator of type beforeDate.
    CompareOperatorBeforeDate CompareOperator = "beforeDate"
    // CompareOperatorAfterDate is a CompareOperator of type afterDate.
    CompareOperatorAfterDate CompareOperator = "afterDate"
    // CompareOperatorExists is a CompareOperator of type exists.
    CompareOperatorExists CompareOperator = "exists"
    // CompareOperatorIsEqualToRating is a CompareOperator of type isEqualToRating.
    CompareOperatorIsEqualToRating CompareOperator = "isEqualToRating"
    // CompareOperatorIsNotEqualToRating is a CompareOperator of type isNotEqualToRating.
    CompareOperatorIsNotEqualToRating CompareOperator = "isNotEqualToRating"
    // CompareOperatorIsGreaterThanRating is a CompareOperator of type isGreaterThanRating.
    CompareOperatorIsGreaterThanRating CompareOperator = "isGreaterThanRating"
    // CompareOperatorIsLessThanRating is a CompareOperator of type isLessThanRating.
    CompareOperatorIsLessThanRating CompareOperator = "isLessThanRating"
    // CompareOperatorIsGreaterThanOrEqualToRating is a CompareOperator of type isGreaterThanOrEqualToRating.
    CompareOperatorIsGreaterThanOrEqualToRating CompareOperator = "isGreaterThanOrEqualToRating"
    // CompareOperatorIsLessThanOrEqualToRating is a CompareOperator of type isLessThanOrEqualToRating.
    CompareOperatorIsLessThanOrEqualToRating CompareOperator = "isLessThanOrEqualToRating"
    // CompareOperatorBetweenDates is a CompareOperator of type betweenDates.
    CompareOperatorBetweenDates CompareOperator = "betweenDates"
)
```

<a name="ParseCompareOperator"></a>
### func ParseCompareOperator

```go
func ParseCompareOperator(name string) (CompareOperator, error)
```

ParseCompareOperator attempts to convert a string to a CompareOperator.

<a name="CompareOperator.IsValid"></a>
### func \(CompareOperator\) IsValid

```go
func (x CompareOperator) IsValid() bool
```

IsValid provides a quick way to determine if the typed value is part of the allowed enumerated values

<a name="CompareOperator.MarshalText"></a>
### func \(CompareOperator\) MarshalText

```go
func (x CompareOperator) MarshalText() ([]byte, error)
```

MarshalText implements the text marshaller method.

<a name="CompareOperator.Scan"></a>
### func \(\*CompareOperator\) Scan

```go
func (x *CompareOperator) Scan(value interface{}) (err error)
```

Scan implements the Scanner interface.

<a name="CompareOperator.String"></a>
### func \(CompareOperator\) String

```go
func (x CompareOperator) String() string
```

String implements the Stringer interface.

<a name="CompareOperator.UnmarshalText"></a>
### func \(\*CompareOperator\) UnmarshalText

```go
func (x *CompareOperator) UnmarshalText(text []byte) error
```

UnmarshalText implements the text unmarshaller method.

<a name="CompareOperator.Value"></a>
### func \(CompareOperator\) Value

```go
func (x CompareOperator) Value() (driver.Value, error)
```

Value implements the driver Valuer interface.

<a name="ControlType"></a>
## type ControlType

ControlType ENUM\(

```
bool
enum
float
integer
string
dateTime
uuid
autocomplete
```

\)

```go
type ControlType string
```

<a name="ControlTypeBool"></a>

```go
const (
    // ControlTypeBool is a ControlType of type bool.
    ControlTypeBool ControlType = "bool"
    // ControlTypeEnum is a ControlType of type enum.
    ControlTypeEnum ControlType = "enum"
    // ControlTypeFloat is a ControlType of type float.
    ControlTypeFloat ControlType = "float"
    // ControlTypeInteger is a ControlType of type integer.
    ControlTypeInteger ControlType = "integer"
    // ControlTypeString is a ControlType of type string.
    ControlTypeString ControlType = "string"
    // ControlTypeDateTime is a ControlType of type dateTime.
    ControlTypeDateTime ControlType = "dateTime"
    // ControlTypeUuid is a ControlType of type uuid.
    ControlTypeUuid ControlType = "uuid"
    // ControlTypeAutocomplete is a ControlType of type autocomplete.
    ControlTypeAutocomplete ControlType = "autocomplete"
)
```

<a name="ParseControlType"></a>
### func ParseControlType

```go
func ParseControlType(name string) (ControlType, error)
```

ParseControlType attempts to convert a string to a ControlType.

<a name="ControlType.IsValid"></a>
### func \(ControlType\) IsValid

```go
func (x ControlType) IsValid() bool
```

IsValid provides a quick way to determine if the typed value is part of the allowed enumerated values

<a name="ControlType.MarshalText"></a>
### func \(ControlType\) MarshalText

```go
func (x ControlType) MarshalText() ([]byte, error)
```

MarshalText implements the text marshaller method.

<a name="ControlType.Scan"></a>
### func \(\*ControlType\) Scan

```go
func (x *ControlType) Scan(value interface{}) (err error)
```

Scan implements the Scanner interface.

<a name="ControlType.String"></a>
### func \(ControlType\) String

```go
func (x ControlType) String() string
```

String implements the Stringer interface.

<a name="ControlType.UnmarshalText"></a>
### func \(\*ControlType\) UnmarshalText

```go
func (x *ControlType) UnmarshalText(text []byte) error
```

UnmarshalText implements the text unmarshaller method.

<a name="ControlType.Value"></a>
### func \(ControlType\) Value

```go
func (x ControlType) Value() (driver.Value, error)
```

Value implements the driver Valuer interface.

<a name="LogicOperator"></a>
## type LogicOperator

LogicOperator ENUM\(

```
and
or
```

\)

```go
type LogicOperator string
```

<a name="LogicOperatorAnd"></a>

```go
const (
    // LogicOperatorAnd is a LogicOperator of type and.
    LogicOperatorAnd LogicOperator = "and"
    // LogicOperatorOr is a LogicOperator of type or.
    LogicOperatorOr LogicOperator = "or"
)
```

<a name="ParseLogicOperator"></a>
### func ParseLogicOperator

```go
func ParseLogicOperator(name string) (LogicOperator, error)
```

ParseLogicOperator attempts to convert a string to a LogicOperator.

<a name="LogicOperator.IsValid"></a>
### func \(LogicOperator\) IsValid

```go
func (x LogicOperator) IsValid() bool
```

IsValid provides a quick way to determine if the typed value is part of the allowed enumerated values

<a name="LogicOperator.MarshalText"></a>
### func \(LogicOperator\) MarshalText

```go
func (x LogicOperator) MarshalText() ([]byte, error)
```

MarshalText implements the text marshaller method.

<a name="LogicOperator.Scan"></a>
### func \(\*LogicOperator\) Scan

```go
func (x *LogicOperator) Scan(value interface{}) (err error)
```

Scan implements the Scanner interface.

<a name="LogicOperator.String"></a>
### func \(LogicOperator\) String

```go
func (x LogicOperator) String() string
```

String implements the Stringer interface.

<a name="LogicOperator.UnmarshalText"></a>
### func \(\*LogicOperator\) UnmarshalText

```go
func (x *LogicOperator) UnmarshalText(text []byte) error
```

UnmarshalText implements the text unmarshaller method.

<a name="LogicOperator.Value"></a>
### func \(LogicOperator\) Value

```go
func (x LogicOperator) Value() (driver.Value, error)
```

Value implements the driver Valuer interface.

<a name="ReadableValue"></a>
## type ReadableValue

ReadableValue is a generic type that represents a human\-readable value with a corresponding backend value. It has two fields: \`Label\` \(the human\-readable form of the value\) and \`Value\` \(the value for the backend\).

```go
type ReadableValue[T any] struct {
    // Label is the human-readable form of the value
    Label string `json:"label"`
    // Value is the value for the backend
    Value T   `json:"value"`
}
```

<a name="Request"></a>
## type Request

Request is a struct representing a filter request. Operator is the logic operator used for the request. Fields is a slice of RequestField, representing the fields to be used for the filtering.

```go
type Request struct {
    Operator LogicOperator  `json:"operator" binding:"required"`
    Fields   []RequestField `json:"fields" binding:"dive"`
}
```

<a name="RequestField"></a>
## type RequestField

RequestField represents a field in a request Field Name: The name of the field Field Keys: Sequence of keys of a nested key structure \- only used for fields with a nested structure. Example: Tag \-\> Name: ABC \(which would be represented as \[\]string\{"Tag", "Name: ABC"\} \) Field Operator: The comparison operator for the field Field Value: The value of the field, which can be a list of values or a single value

```go
type RequestField struct {
    Name     string          `json:"name" binding:"required"`
    Keys     []string        `json:"keys,omitempty"`
    Operator CompareOperator `json:"operator" binding:"required"`
    // Value can be a list of values or a value
    Value any `json:"value" binding:"required"`
}
```

<a name="RequestOption"></a>
## type RequestOption

RequestOption configures a field for validation

Name: The name of the option Control: The type of control for the option Operators: The list of comparison operators for the option Values: The possible values for the option MultiSelect: Indicates whether the option supports multiple selections

```go
type RequestOption struct {
    Name        ReadableValue[string]
    Control     RequestOptionType
    Operators   []ReadableValue[CompareOperator]
    Values      []string
    MultiSelect bool
}
```

<a name="RequestOptionType"></a>
## type RequestOptionType

RequestOptionType configures the type of control for a field in a request option.

```go
type RequestOptionType struct {
    Type ControlType `json:"type" enums:"string,float,integer,enum,bool"`
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
